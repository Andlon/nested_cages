function [hulls_V,hulls_F,IF_prog,vol_prog] = progressive_hulls_comparison(path_to_directory,basename,num_levels)
  % PROGRESSIVE_HULLS_COMPARISON enters 'path_to_directory' where our
  % cages are stored, generate 'num_levels' progressive hulls with 
  % the same resolution as our results and save them in 
  % 'path_to_directory'/progressive_hulls together with statistics
  % regarding volume and intersections
  %
  % [hulls_V,hulls_F,IF_prog, vol_prog] = progressive_hulls_comparison(path_to_directory,basename,num_levels)
  %
  % Inputs:
  %   path_to_directory  
  %   basename:  name such that the input is basename_0.obj and the cages
  %   are basename_1.obj, ..., basename_7.obj
  %   num_levels  #levels generated by our method
  % Outputs:
  %   hulls_V  array of matrices where hulls_V{1} is the vertex positions
  %   of the coarsest layer ...
  %   hulls_F  array of matrices where hulls_F{1} are vertex indices
  %   of the coarsest layer ...
  %   IF_prog   IF_prog{1} is the num_intersections of the coarsest
  %   layer,...
  %   vol_prog  vol_prog{1} is the volume of the coarsest layer...
  %
  % TODO: incorportate mex function that computes progressive hulls and
  % re-run
  
  path_to_progressive_hulls = '../progressive-hulls-novis/progressive_hulls_novis';
  [V0,F0] = load_mesh(sprintf('%s/%s_0.obj',path_to_directory,basename));
  
  % load our nested cages
  for k=1:num_levels
      [cages_V{num_levels+1-k},cages_F{num_levels+1-k}] = load_mesh(sprintf('%s/%s_%d.obj',path_to_directory,basename,k));
      levels(k) = size(cages_F{num_levels+1-k},1);
  end
  
  % compute progressive hulls
  [hulls_V,hulls_F] = progressive_hulls_prompt(sprintf('%s/%s_0.obj',path_to_directory,basename),levels);
  hulls_V{num_levels+1} = V0;
  hulls_F{num_levels+1} = F0;
  write_cages(sprintf('%s/progressive_hulls/%s',path_to_directory,basename),hulls_V,hulls_F);
  
  IF_prog = zeros(num_levels,1);
  IF_ours = zeros(num_levels,1);
  vol_prog = zeros(num_levels,1);
  vol_ours = zeros(num_levels,1);
  
  for k=1:num_levels
      
      % compute intersections
      IF_prog(k) = size(intersect_other(V0,F0,hulls_V{k},hulls_F{k}),1);
      IF_ours(k) = size(intersect_other(V0,F0,cages_V{k},cages_F{k}),1);
      
      % compute volumes
      [~,vol_prog(k)] = centroid(hulls_V{k},hulls_F{k});
      [~,vol_ours(k)] = centroid(cages_V{k},cages_F{k});
      
  end
  
  stats_file = sprintf('%s/progressive_hulls/%s_stats.mat',path_to_directory,basename);
  save(stats_file,'IF_prog','IF_ours','vol_prog','vol_ours');
  
%   for k=size(levels,2):-1:1
%       
%       to_collapse = sprintf('%d',floor((size(F0,1)-levels(k))/2));
%       command = [path_to_progressive_hulls ' ' path_to_mesh ' ' to_collapse];
%       disp(command);
%       
%       [status, result] = system(command)
%       if status~=0
%           error(result)
%       end
%       
%       [V_prog,F_prog] = load_mesh('progressive.obj');
%       [RV,IM] = remove_unreferenced(V_prog,F_prog);
%       RF = IM(F_prog);
%       RF_small = RF(all(diff(sort(RF'))),:);
%       
%       hulls_V{k} = RV;
%       hulls_F{k} = RF_small;
%       
%   end