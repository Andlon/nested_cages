\section{Introduction}
\label{sec:introduction}

\begin{figure}[b]
  \includegraphics[width=\linewidth]{figs/horse-25-layers}
  \caption{Our tight nesting property is robust even when the number of cages
  is large: 25 around this \emph{Horse}.}
  \label{fig:horse-25-layers}
\end{figure}

As the complexity and size of computational objects continue to grow,
acceleration algorithms become increasingly important. One powerful technique
is to decompose a high-resolution mesh into a hierarchy of increasingly coarse
approximations or \emph{cages} (see \reffig{teaser}). For example,
multiresolution FEM techniques efficiently solve Eulerian PDEs on very fine
meshes by moving up and down the hierarchy; low frequency residual error
disappears quickly on the coarsest levels while fine levels smooth away high
frequency error. Coarse enclosing cages also find use in physical simulation,
where deformations of the cage are interpolated onto embedded high-resolution
geometries; in interactive animation, where artists specify large-scale
deformations by adjusting the low-dimensional cage; and in collision detection,
where conservative culling reduces computation time. For all these
applications, the key to high performance is the ability to generate a quality
multiresolution hierarchy.

The straightforward approach to building a hierarchy around an object $\Fout$
is to use an application-specific decimation algorithm to build a coarse
approximation $\Cout$ to $\Fout$; $\Cout$ itself can be further coarsened to
build the next level of the hierarchy, etc. (see \reffig{horse-25-layers}).
Unfortunately $\Cout$ will typically intersect $\Fout$, which is often
undesirable: most algorithms for transferring the pose of a deformation cage to
a detailed object only guarantee small distortion of the object and lack of
element-inversion artifacts if the object is entirely contained within the cage
\cite{HarmonicCoodinates07,Ben-Chen:2009:VHM}; strict nesting is essential for
accelerating collision detection \emph{conservatively}; and while nesting is
not a necessary condition for multiresolution convergence
\cite{Chan96overlappingschwarz}, the ability to use simple linear interpolation
for prolongation is known to produce more robust, more efficient, and easier to
implement solvers \cite{chan2000robust,dickopf2010multilevel}. This is
particularly important for enforcing Neumann boundary conditions, common to
simulation and geometry processing \cite{chan1999boundary}.

For these reasons, one would like a cage $\Cout$ that is \emph{nested} around
$\Fout$: that surrounds $\Fout$ without intersecting it. More formally, given
two watertight (connected, closed, self-intersecting-free and oriented)
homeomorphic meshes 
%
$\Cout$ and $\Fout$ (later we generalize our method to build cages for polygon
soups, point clouds, etc.), we say that $\Cout$ \emph{nests} $\Fout$ if: 
%
(i) $\Fout$ is contained in the interior of $\Cout$, and 
%
(ii) there is a homotopy from $\Cout$ to $\Fout$ that remains at all times inside
$\Cout$'s volume. 
This definition extends naturally to polyhedra with voids or multiple connected components that are bounded by watertight meshes.
\clearpage

\begin{wrapfigure}[15]{r}{1.02in}
%
\centering
%
\includegraphics[trim=4mm 0 0mm 0mm,width=\linewidth]{figs/boxer-cages-not-cages}
%
\end{wrapfigure}
%
The inset figure shows examples of cages that do (top) and do not (bottom) nest
a 2D example (black outline). Given a $\Cinp$ that does not nest $\Fout$, we
look for the best perturbation $\Cout$ of $\Cinp$ that does nest $\Fout$; where
``best'' is measured by an application-dependent fitness energy $E(\Fout,
\Cinp, \Cout)$, penalizing, for example, total volume for tight fitting cages
for efficient multiresolution solvers; distortion for simulation or collision
handling; or violations of symmetry and quad-planarity for interactive
deformation cages.  Finding $\Cout$,  entails solving the \emph{nested cage
problem}:

Given an embedded polyhedron $\Fout$, a polyhedron $\Cinp$ homeomorphic to $\Fout$, and a
fitness function $E$, minimize $E(\Fout, \Cinp, \Cout)$ over all embeddings
$\Cout$ of $\Cinp$ that nest $\Fout$.


\begin{figure}
  \includegraphics[width=\linewidth]{figs/torus-counterexample}
  \caption{Some coarse-fine mesh combinations are impossible. The
  \emph{Cs\'asz\'ar torus} is too coarse to nested around the
  \emph{Squiggly torus}'s complex handle. While embedding the \emph{Squiggly
  torus} \emph{inside} the \emph{Cs\'asz\'ar torus} is possible (right), this
  is not a validly \emph{nesting} cage.}
  \label{fig:torus-counterexample}
\end{figure}

This problem in its full generality is intractable. For
single polygons in 2D, and simply-connected meshes in 3D, at least one nested
embedding $\Cout$ always exists, but once $\Fout$ is allowed to have nontrivial
topology, counterexamples exist where it is impossible to embed $\Cinp$ in a way
that nests $\Fout$ (see \reffig{torus-counterexample}). The decision
problem of whether any nesting of $\Cinp$ around $\Fout$ exists can be 
shown to be NP-complete~\cite{CagesNP}.
Fortunately, in practice $\Cinp$ and $\Fout$ are not completely arbitrary; any
reasonable decimation scheme will keep $\Cinp$ morphologically similar, and
roughly aligned, to $\Fout$, and these favorable initial conditions can be
leveraged by heuristics.

\paragraph{Contribution.} We present a practical algorithm for solving the
nested cage problem on meshes typically used in applications such as physical
simulation and geometric modeling. Our method is the first to do so while
remaining completely \emph{agnostic} to the decimation scheme used to create
$\Cinp$ and fitness function $E$. Briefly, the method first flows $\Fout$ inside $\Cinp$
along $\Cinp$'s signed distance field; once inside, we rewind the flow while
deforming $\Cinp$ to minimize $E$; contact forces guarantee that the coarse cage
always encloses $\Fout$ at each reverse-flow time step. This process can be
generalized to building an entire multiresolution hierarchy around $\Fout$.
Although our method is not guaranteed to always find a solution $\Cout$,
especially for very coarse or nearly-self-intersecting $\Fout$ (see
\refsec{conclusion}
for discussion of failure cases), we tested our algorithm on an extensive zoo
of example meshes (see \refsec{results}).

