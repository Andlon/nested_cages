\section{Results and applications}
\label{sec:results}

We implemented a prototype of our method as a serial \textsc{Matlab} program.
%
We report timings of our unoptimized code for a few representative examples in
\reftab{timings} recorded on an iMac Intel Core i7 3.5GHz computer with 8GB
memory.
%
As expected the bottleneck is the collision-free re-inflation step.
%
We experimented with a wide variety of shapes, ranging from CAD models,
characters, and scanned objects (see \reffig{zoo}). By default we compute
layers so that each coarser layer has $2^{-\sfrac{2}{3}}$ times as many facets as
the previous finer layer, a ratio chosen so that resulting tetrahedral
meshes will have approximately $8$ times fewer elements. For most
meshes we compute seven layers, with fewer for lower resolution inputs.
%
In our supplemental material, we attach all input models, corresponding output
cages, and a small program to visualize volumetric slices.

\begin{figure}
  \includegraphics[width=\linewidth]{figs/zoo-single-column}
  \caption{Each triplet shows: input model, slice through all nested layers,
  and outermost, coarsest layer. 
  As a stress test, we purposefully continue nesting cages around \emph{Gargoyle} to a
  very coarse level (bottom left).
  %
  The topological holes of the high-genus \emph{Fertility} are maintained
  across all layers (top right). 
  %
  The deep concavity of the \emph{Mug} does not
  get smoothed away in coarser levels (bottom right).
  }
  \label{fig:zoo}
  \vspace{-2mm}
\end{figure}

\input{timings_table}

Our method is agnostic to the decimator used to create the input meshes
$\Minp_1,\dots,\Minp_k$. In this way we inherit the feature set of the
decimator. 
%
\reffig{decimations}
compares using the regular mesh inducing decimator in \cite{cgal} (default for
all remaining examples) and the feature-adaptive decimator of \cite{openmesh}.
% Meshfix is mentioned at beginning of method.tex

\begin{figure}
  \includegraphics[width=\linewidth]{figs/coupling-down-decimators}
  \caption{By post-processing meshes from any existing decimator, our output
  inherits desired regularity or adaptivity of the decimation.}
  \label{fig:decimations}
\end{figure}

%\alec{INSERT ENERGY COMPARISON HERE}
%
%
%\begin{figure}
%  \includegraphics[width=\linewidth]{figs/energies_volume_surfarap.png}
%  \caption{The cage obtained by minimizing the volume energy (left)
%  does present a tight fit but may lead to mesh quality artefacts.
%  On the other hand, minimizing surface ARAP (right) preserves the mesh
%  quality of the initial (non-regular) decimation but leads to extra volume.}
%  \label{fig:energies}
%\end{figure}

To test robustness, we compare computing seven nested cages on the \emph{Bunny}
and the same model corrupted with noise in the normal direction (see
\reffig{noisy-bunny}). The resulting layers tightly hug both shapes, producing
similar outermost cages.

\begin{figure}
  \includegraphics[width=\linewidth]{figs/noisy-bunny}
  \caption{Noise added in the normal direction to the input bunny does not
  affect our ability to generate seven quality outer layers.}
  \label{fig:noisy-bunny}
\end{figure}

We also conducted stress tests to evaluate how well our method scales with the
number of layers. We nest 25 tightly fitting layers around the \emph{Horse} in
\reffig{horse-25-layers} and 50 around \emph{Max Planck} in \reffig{max-planck}, top
left.
%
We purposefully continue nesting cages around the the \emph{Gargoyle} in
\reffig{zoo}, bottom left, until only eight vertices of an extremely coarse
cage remain.

\newhl{For some applications (e.g. conservative collision detection) there is no need
for the output cage to be homeomorphic to the input mesh. Our definition of the problem in \refsec{introduction} allows the cage to have less handles than the input mesh. \reffig{elephants} illustrates this point, where we generate a cage that is homeomorphic to the input mesh (center) and another cage that has smaller genus (right).}

\begin{figure}
  \includegraphics[width=\linewidth]{figs/max-planck}
  \caption{ We fit 50 layers tightly around \emph{Max Planck}'s head.}
  \label{fig:max-planck}
\end{figure}

\begin{figure}
  \includegraphics[width=\linewidth]{figs/elephants_placeholder.png}
  \caption{\newhl{Depending on the target application, our method generates
  cages homeomorphic to the input mesh (center) or with handles
  removed (right).}}
  \label{fig:elephants}
\end{figure}

\begin{figure}
  \includegraphics[width=\linewidth]{figs/octopus-poisson}
  \caption{A single multigrid v-cycle takes 1.4 secs on this 7M-vertex
  volumetric Poisson equation in the \emph{Octopus}. With 14 more iterations
  (21 secs) the residual error matches a direct solver's (11 mins, back
  substitution only).}
  \label{fig:octopus-poisson}
\end{figure}
\begin{figure}
  \includegraphics[width=\linewidth]{figs/pelvis-diffusion}
  \caption{We solve a diffusion equation $(λ∆+I) x = b$ for various diffusion
  rates $λ$ with our nested cages in a volumetric multiresolution solver (top:
  surface values via Neumann boundary conditions, bottom: slice through
  tet-mesh volumes).}
  \label{fig:pelvis-diffusion}
\end{figure}

Constructing our nested cages can be considered expensive \emph{precomputation}
for a multiresolution linear system solver.
%
However, once cage meshes are computed and their interiors are meshed with
tetrahedra (e.g.\ using \cite{tetgen}),
the volumetric multigrid solver is sleek and memory efficient.
%
A single multiresolution V-cycle for a Poisson equation with homogeneous
Dirichlet boundary conditions inside the volume of the \emph{Octopus} with over
seven million vertices takes 1.4 seconds using 2GB max memory. With 14 more
V-cycles the solution converges for a total time of 21 seconds (see
\reffig{octopus-poisson}).
%
In contrast, \textsc{Matlab}'s backslash operator thrashes when using over 22GB
of memory finishing in over 16 minutes.
%
\textsc{Cholmod}'s Cholesky factorization with reordering is mildly better than
\textsc{Matlab}, solving via backsubstitution in 10 minutes, but suffers from
similar memory issues during factorization, which takes over
an hour using 17GB max memory, due to high fill-in.
%
In terms of precomputation, our time consuming cage computation lives at a much
earlier stage than system-matrix factorization: before determining constraints
or boundary conditions and before even choosing the particular system being
solved.
%
This is even true for inhomogeneous systems where local metrics are
varying between solves. In this case, the internal tet-meshing might need to be
recomputed (seconds for \emph{Octopus}), but our boundary cages can be reused.
%
Since all fine mesh vertices are inside coarse-mesh tetrahedra, we use linear
interpolation for prolongation and its transpose for restriction
\cite{Demmel04}.

\begin{wrapfigure}{r}{1.02in}
%
\centering
%
\includegraphics[trim=0 0 0 3mm,width=\linewidth]{figs/pelvis-plot}
%
\end{wrapfigure}
%
As we do not alter the core iterative nature of multiresolution, we benefit
from its flexibility. For example, we may quickly change the diffusion rate in
a heat equation solved in the volume of the \emph{Pelvis} (see
\reffig{pelvis-diffusion}). 
%
Factorization based solvers, in general, scrap previous precomputation after
such a global change to the system matrix. 
%
Multiresolution hardly notices, and previous solutions become warm starts.
%
We employ Neumann boundary conditions and notice that naively decimating the
input mesh leads to a divergent solver (inset), agreeing with previous analysis
that nesting is important for such boundary conditions \cite{chan1999boundary}.
%
Because naive decimations do not nest, the prolongation operator must
extrapolate for fine mesh vertices lying outside the coarse domain.
%
It \emph{may} be
possible to tweak extrapolation parameters to handle these cases with naive
decimation, but an automatic method for correcting extrapolation for
convergence is not obvious.
%
For comparisons, we tried: linear extrapolation from the nearest tet, constant
interpolation of nearest vertex, linear interpolation at the closest point on
nearest face. We compare to the most favorable choice.


\begin{figure}
  \includegraphics[width=\linewidth]{figs/armadillo-heat-plot}
  \caption{We solve for smooth geodesics over volumetric tetrahedral mesh
  inside the \emph{Armadillo}. Using naive overlapping and
  shrinking decimations leads to divergence unless a very large number of
  relaxation iterations is used.  Ours is always convergent.}
  \label{fig:armadillo-heat-plot}
\end{figure}

On less challenging domains, naive decimations can be used, but may require
many relaxation (a.k.a.\ smoothing) iterations on each level of each v-cycle.
%
In \reffig{armadillo-heat-plot}, we compute smooth geodesics via two Poisson
equations in the volume of the \emph{Armadillo} \cite{Crane:2013:RFV}.
%
Using our nested cages, the multiresolution solver converges independent of the
number of relaxation iterations used (typically fewer relaxation iterations and
more v-cycles is preferable).
%
In contrast, multiresolution using naive non-nested decimations converge when
using a large number of relaxation iterations, and then at a rate equivalent to
single relaxation iteration with our meshes.

A single enclosing cage is useful for creating a lower dimensional volumetric
domain for elastic simulation of an input model that is either too high
resolution or complicated by meshing imperfections \cite{Xu:2014:SDF}.
%
In \reffig{frankenstein-physics}, we compare to extracting the outer hull of
the multi-component and self-intersecting \emph{Frankenstein} using
\cite{Jacobson:WN:2013}.
%
While technically a ``perfectly tight fit'', this cage fails to coarsen the
domain and meshing near intersections creates sliver triangles problematic for
numerics.
%
We also compare to signed-distance field contouring \cite{Xu:2014:SDF}, which
creates a loose fit joining the legs near the knees.
%
With the same vertex count, our cage is a tight fit making it especially
suitable for elastic simulation with collision handling.
%
The deformation of the volume inside the coarse cage is then propagated via
linear interpolation to the embedded mesh (see also accompanying video).

\begin{figure}
  \includegraphics[width=\linewidth]{figs/frankenstein-physics-02}
  \caption{Extracting an outer hull with Jacobson et al~\protect\shortcite{Jacobson:WN:2013} fails to coarsen the domain (top
  left). Contouring a distance field achieves nesting at a large
  iso-level but fuses the legs (top center). Our coarse cage fits the input
  tightly and provides a reduced domain for real-time physics.}
  \label{fig:frankenstein-physics}
\end{figure}

\begin{figure}
  \includegraphics[width=\linewidth]{figs/hand-hc}
  \caption{Left to right: a quad mesh is quickly sketched atop the \emph{Hand}
  and our pipeline moves it outside the input while planarizing quads. A
  cage-based deformation is applied via harmonic coordinates computed over the
  volume inside the planar-quad polyhedron (a few coordinates visualized in
  pseudocolor). These weights are smooth inside each quad. In contrast,
  triangulating the quads would lead to non-smooth, meshing-dependent values in
  each quad (two alternative triangulations).}
  \label{fig:hand-hc}
\end{figure}

Another application area for nested cages is collision detection for rigid
objects: if an object does not collide against a surface enclosing a second
object, 
this certifies that the two objects do not collide either.
%
Bounding sphere, cubes, and
higher-degree polytopes are often used to quick-reject candidate collisions for
this reason, but these convex cages lose effectiveness when objects are concave
or have holes and cavities. On the other hand, a coarse nested cage is ideal
for this purpose, since the nesting property guarantees correctness and the
tight fit allows the coarse cage to efficiently reject nearly all false
positives during collision detection. As a proof of concept, we simulated
dropping eighteen instances of the octopus mesh (\reffig{zoo},
top-middle) one by one into a narrow tank, where they collide with each other
and the tank walls (\newhl{with} coefficient of restitution $0.99$) using
continuous-time collision detection (see inset). We compared the performance of
two different broad phase strategies for collision detection: 
%
\begin{wrapfigure}[21]{r}{1.02in}
%
\vspace*{-5mm}
\centering
%
\includegraphics[trim=4mm 0 0 1mm,width=\linewidth]{figs/octopi-collisions}
%
\end{wrapfigure}
%
in the first,
bounding cubes around swept spacetime volumes are used to prune distant pairs
of objects from consideration, then kDOP bounding volume hierarchies are built
to find candidate colliding vertex-face pairs, which are then passed to the
continuous-time narrow phase. The second strategy is the same, except
that we first check if the octopus's coarse cage is colliding before building
the BVH on the octopus itself. We found that the latter strategy is 
$\sim 8\times$ faster, for intuitive reasons: the octopus's many
protruding arms causes it to easily nestle near other copies of itself, so that
their convex hulls overlap but our tight, coarse cage does not.
%
Nesting is applicable for rigid or nearly rigid objects, but it is not obvious
to track cages along with deformable bodies, unless, for example, deformations
could be precomputed.

A single very coarse cage is needed for interactive deformation with
generalized barycentric coordinates.
%
In \reffig{dane-vs-ben-chen}, we compare to the automatic cage creation
heuristic in \cite{Ben-Chen:2009:SDT} and see much tighter fits for matching
vertex counts.

The ability to customize our optimization energy enables not just better cages,
but also better generalized barycentric coordinates. In particular, harmonic
coordinates are defined for arbitrary polyhedra, yet most works implement them
inside triangle-mesh cages only \cite{HarmonicCoodinates07}.
%
To utilize popular quad-dominant meshes as cages, all faces must be outside the
input model and \emph{planar}.
%
Since such cages are difficult to model manually, many implementations simply
triangulate high-order facets \cite{HarmonicCoodinates07}.
%
We complement the recent sketch-based quad-meshing tool \cite{Takayama:2013},
post-processing its output to enclose the input model and minimize a
planarization energy \cite{poranne2013interactive}.
%
Quad-dominant cages are easier to control as their visualization is less
cluttered (see \reffig{hand-hc}).
%
More importantly, harmonic coordinates constructed (via their recursive
definition) on the planar-quad polyhedron are also higher quality: coordinates
are smooth functions inside each quad.
%
In contrast, coordinates of a triangulated cage would depend heavily on the
choice of diagonals splitting each quad.

\paragraph{Generalizations beyond watertight meshes.}
%
Though not strictly meeting our input criteria, we apply our method to
polygon soups. % and point clouds.
%
In \reffig{swat-cage}, we again adapt the optimization energy, this time to
maintain the reflectional symmetry of the coarse input cage.
%
The input polygon soup \emph{S.W.A.T.\ man} is riddled with meshing artifacts,
but we still flow it inside.
%
Though details on the expanding input mesh are asymmetric (see hip pockets or
hands), the energy minimization keeps the cage symmetric.
%
%In \reffig{point-cloud}, we use Poisson surface reconstruction and decimation
%to compute an initial cage for a point cloud and then nest it around the points
%using our method.
%
%\begin{figure}
%  \includegraphics[width=\linewidth]{figs/point-cloud}
%  \caption{Our pipeline generalizes to non-polyhedral inputs such as point
%  clouds.}
%  \label{fig:point-cloud}
%\end{figure}

\begin{figure}
  \includegraphics[width=\linewidth]{figs/swat-cage}
  \caption{\emph{S.W.A.T. man} is a polygon soup with 2806 
  intersecting triangle pairs, 24 non-manifold edges, 51 boundary loops and 51
  components. Our shrinking flow is robust to such artifacts. Once
  inside the coarse, overlapping input cage, we re-inflate it and produce a
  fully exterior cage used to deform the embedded model.}
  \label{fig:swat-cage}
\end{figure}
