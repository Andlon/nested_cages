\section{Method}
\label{sec:method}

% establish input and output
The input to our method is a sequence of $k+1$ potentially overlapping triangle
meshes $\Minp_0,\Minp_1,\dots,\Minp_k$.
%
Each mesh $\Minp_i$ has a corresponding list of \emph{initial} vertex positions
$\MVinp_i \in \R^{n_i \times 3}$ and list of triangle indices $\T_i \in
\{1,\dots,n_i\}^{m_i \times 3}$.
%
In a typical scenario, $\Minp_0$ is a high-resolution \emph{original} mesh and
$\Minp_1,\dots,\Minp_k$ are decimations of decreasing resolution; the method of
decimation is unimportant so long as the input meshes all roughly approximate
$\Minp_0$, and are all \emph{watertight} \cite{Dey:2003jf}:
%
free of open boundaries, non-manifold elements, or
self-intersections.\footnote{Our input assumptions are stricter than the
\emph{solidness} of \cite{Bernstein:2013:PHH} whose definition permits
non-manifold ``shared'' vertices and edges.}
%
Depending on the application, troublesome input meshes can be \emph{cleaned} as
a pre-process using available tools (e.g.\
\cite{Attene:2010vv,Jacobson:WN:2013}).

The output of our method is a new sequence of $k$ lists of vertex positions
$\MVout_1,\dots,\MVout_k$ such that for $i=1\dots k$ each $\Mout_i =
(\MVout_i,\T_i)$ is a deformed mesh whose surface (i.e. all points on all
faces, not just the vertices) lies strictly outside $\Mout_{i-1}$ (with
$\Mout_0 = \Minp_0$.) Recursively this ensures that each $\Mout_i$ lies
strictly outside $\Mout_j$ for $j=i-1,\dots,0$. We call such meshes
\emph{nested} (see \reffig{boxing-layers}).

\begin{figure}
  \includegraphics[width=\linewidth]{figs/boxing-layers}
  \caption{We deform a set of input overlapping decimations so that each
  contains all finer layers (2D illustration).}
  \label{fig:boxing-layers}
\end{figure}

We opt to alter only the vertex positions (\emph{geometric embedding}) of each
mesh, and not the number or connectivity of vertices ($\T_i$ are unchanged).
Among other benefits, this decision ensures that the number of vertices
in each decimated mesh is exactly maintained.

The \emph{nesting} property of the output meshes is easily verified by
testing that at least one vertex of $\MVout_{i-1}$ lies on the interior of
$\Mout_i$ (by e.g. checking that its winding number is positive)
and that no intersections exist between $\Mout_{i-1}$ and $\Mout_i$.

We now describe a general method that guarantees this nesting property while
also optimizing any problem-specific energy (e.g.\ mesh
total volume, mesh surface quality) that measures the fit of one layer with respect to the next.

Our method operates recursively on two meshes of the sequence at a time: we
compute $\Mout_i$ by considering only its original embedding $\Minp_i$ and the
solution to the previous level $\Mout_{i-1}$. 
%
In this way we compute $\Mout_1,\Mout_2,\dots,\Mout_k$ in order, ensuring
nesting between each subsequent pair.
%
Breaking the problem of nesting many cages into individual subproblems is key
to our success as it greatly reduces the complexity of the collision and optimization subproblems. 

To simplify notation, from now on, we only consider computing the new positions
of a \emph{coarse} mesh $\Cout$ from its original mesh $\Cinp$ and the next
\emph{finer} output mesh $\Fout$. 
%
Computing new coarse mesh vertex positions $\CVout$ involves two phases:
\emph{flow} of the fine mesh until it is fully inside the coarse mesh, and \emph{re-inflation}
of the fine mesh to its original embedding while \emph{pushing} the coarse mesh
out of the way (see \reffig{boxing-pipeline}).

\begin{figure}
  \includegraphics[width=\linewidth]{figs/boxing-pipeline}
  \caption{Our pipeline has two stages for each pair of neighboring coarse
  $\Cout$ and fine $\Fout$ layers.}
  \label{fig:boxing-pipeline}
\end{figure}

\subsection{Flow}
\label{sec:flow}

The first step of our pipeline is to find a new positions $\FVflow$ for the fine mesh that
\emph{minimizes total signed distance} to $\Cinp$ integrated over all deforming surface
points $\pflow \in \Fflow$:
%
\begin{equation}
\label{equ:sd-energy}
 Φ(\FVflow) = ∫\limits_{\Fout} s(\pflow) d(\pflow) \,dA,
\end{equation}
%
where $d(\pflow)$ is the unsigned distance from $\pflow$ to
the coarse mesh and $s(\pflow)$ modulates by the appropriate sign. 
%
\begin{wrapfigure}{r}{1.02in}
%
\centering
%
\includegraphics[width=\linewidth]{figs/cutting-corners}
%
\end{wrapfigure}
%

We minimize this energy by taking small steps opposite the gradient direction
for each vertex position $\fflow$ in $\FVflow(t)$ as a function
of a fictitious \emph{time} variable $t$:
\begin{equation}
\dd{\fflow}{t} = -\nabla_{\fflow} Φ(\FVflow) \label{eq:flow}
\end{equation}
%
By following this gradient, we \emph{flow} the fine mesh vertices $\Fflow(t)$
until fully inside the coarse mesh (detected by performing an intersection test each time step).

Our energy is similar to the data terms found in non-rigid registration
techniques \cite{chang2010geometric}. However, the sign modulator $s(\pflow)$
makes an important difference. Minimizing unsigned (positive) distances would
flow points toward the surface of the coarse mesh.  Instead, by allowing and
encouraging negative distances, points are attracted to the medial axis
\emph{within} the coarse mesh.

Since the energy~\eqref{equ:sd-energy} is nonlinear, we approximate the gradient~\eqref{eq:flow} using numerical quadrature:
%
For each triangle $T_i$ incident on vertices $a,b,c$, we sample $s$ and $d$ at quadrature points $\pflow_j$ and with corresponding weights $w_j$,
$j=1,\dots,h$:
%
\begin{align*}
Φ(\FVflow) &= ∑_{i=1}^{m_F}
  \,∫\limits_{\pflow \in T_i} s(\pflow) d(\pflow)\,dA.
 &\approx ∑_{i=1}^{m_F} ∑_{j=1}^h w_j s(\pflow_j) d(\pflow_j),\\
& \pflow_j = 
λ_a \fflow_a + 
λ_b \fflow_b + 
λ_c \fflow_c,
\end{align*}
where $λ_a,λ_b,λ_c$ are the barycentric coordinates locating
$\pflow_j$ in $T_i$.
%
We use second-order quadrature rules and see diminishing returns with more
exact schemes.

The difficulty of differentiating the unsigned distance function
$d(\pflow_j)$ remains. To tackle this, we adapt the successful iterative
closest point approach of non-rigid registration techniques. Namely, we assume
that the closest point $\qinp_j^*$ to each $\pflow_j$ and sign
$s(\pflow_j)=s_j^*$ remain constant
during each small time step.

We may now push the gradient through the summation to the terms involving each
vertex positions $\fflow$:
\begin{align}
\dd{\fflow}{t} &\approx -\sum_{i\in N(\fflow)} \sum_{j=1}^h w_j s_j^* ∇_{\fflow} \|\pflow_j -\qinp_j^*\|,\\
\end{align}
where $N(\fflow)$ gathers all triangles incident on vertex $\fflow$. Applying
the chain rule, and handling the special case where $\pflow_j\approx \qinp_j^*$
(i.e.\ when our
assumption that $s(\pflow_j)=s_j^*$ is invalid), we arrive at
\begin{align}
\dd{\fflow}{t} &\approx 
-∑_{i\in N(\fflow)} ∑_{j=1}^h w_j s_j^* (\nabla_{\fflow} \pflow_j)^\transpose ∇_{\pflow_j}
\|\pflow_j -\qinp_j^*\| \\
&=
-∑_{i\in N(\fflow)} ∑_{j=1}^h w_j λ_f \g_i,\\
,\\
&\text{ where } \g_i = \begin{cases}
s_j^* \frac{\widehat{\p}_i -\q_i^*}{\|\widehat{\p}_i -\q_i^*\|} & \text{ if } \|\widehat{\p}_i
-\q_i^*\|<\epsilon,\\
\n(\q_i^*) & \text{ otherwise },
\end{cases}
\end{align}
where $λ_f$ is the barycentric coordinate of $\pflow_i$ corresponding to
$\fflow$ and $\n(\q_i^*)$ is the unit normal at $\q_i^*$. This normal is chosen
with care to ensure that it points \emph{inside} the coarse mesh. We determine
if $\q_i^*$ lies near a vertex, near an edge or in the middle of a triangle and
use an interior-angle-weighted average of incident triangle normals, a uniform
average of incident triangle normals, or triangle normal, respectively~\cite{Baerentzen:2005:SDC}.

We use a fictitious time step size $∆t \approx 10^{-3}$ for our models (all of which were scaled to unit diameter), using a
line search along the descent direction to determine a step with non-negative
progress toward reducing the energy $Φ$.
%
After each time step we update signs $s_i^*$ and closest points $\q_i^*$ for
all quadrature points. We terminate if all signs are negative \emph{and} no
intersecting faces are found between $\Fflow$ and $\Cinp$.
%

%
\begin{wrapfigure}{r}{1.02in}
%
\centering
%
\includegraphics[width=\linewidth]{figs/boxer-medial-axis-vert}
%
\end{wrapfigure}
%
There is no formal, provable guarantee that this flow will succeed in removing all intersections. Indeed, in
difficult cases the flow converges without moving the fine mesh fully
inside the coarse mesh (e.g.\ when all quadrature points lie near the medial
axis).  This failure may also occur if the coarse mesh so poorly matches the fine mesh
that its medial axis lies significantly outside of the fine mesh. However, if the input sequence results from decimation which 
effectively \emph{prunes} a shape's medial axis (see inset), failure of the flow is rare in practice.

%\begin{figure}
%  \includegraphics[width=\linewidth]{figs/boxer-medial-axis}
%  \caption{The fine mesh will flow toward the medial axis of the
%  coarse mesh (red, left), which is typically a simplification of the fine
%  mesh's medial axis (right).}
%  \label{fig:boxer-medial-axis}
%\end{figure}

In particularly difficult cases, we propose an additional step: we reverse the picture and
expand the \emph{coarse} mesh, flowing it \emph{away} from the current fine mesh along its
signed distance field. Contact forces must also be included in this case to ensure the coarse mesh does
not flow into a configuration where it self-intersects. Fortunately, in these hard cases only a few expansion steps are typically necessary.


\paragraph{Relationship to other flows}
%
Many smoothing flows produce shrinking effects
\cite{Taubin:1995,desbrun99implicitfairing,Crane:2013:RFV}. For the purpose of
fairing, volume loss is often actively avoided \cite{desbrun99implicitfairing}.
%
Without volume preservation the flows may eventually shrink to the shape's
medial axis \cite{Wang:2008,Au:2008,Tagliasacchi:2012:MCS} or to a round point
\cite{Kazhdan2012}, but these flows make no effort to keep the flowing surface
strictly \emph{inside} its original volume (much less the volume of a nearby
coarse decimation). Such wandering flows will cause unnecessary complications
in the re-inflation step we describe next (see \reffig{rampant-flow}).
%
Our signed distance flow does not produce aesthetically fair surfaces, indeed
the fine mesh quickly becomes entangled and self-intersecting. This is not a defect: we do not care about the quality of the surface so long as it quickly
flows inside the coarse mesh. As we now describe, the fine mesh will
\emph{re-inflate} to its original positions.

\begin{figure*}
  \includegraphics[width=\linewidth]{figs/rampant-flow}
  \caption{Mean curvature flow \protect\cite{Kazhdan2012} shrinks the fine mesh
  (blue), but via a path outside the coarse mesh (wireframe).  During
  re-inflation this causes unnecessary collisions, leading to failure.
  Instead, our flow directly flows the fine mesh into the coarse mesh.}
  \label{fig:rampant-flow}
\end{figure*}

\subsection{Re-inflation}
\label{sec:reinflation}

After the flow step, $\Fflow$ is fully
inside $\Cinp$. We now restore the fine mesh to its original vertex positions
$\FVout$, detecting and resolving collisions with the coarse mesh along the way
(see \reffig{boxing-pipeline}).

Jumping directly from $\FVflow$ to $\FVout$ would typically introduce an
unwieldy number of collisions: too many to disentangle. Fortunately, our
previously described signed distance flow provides a meaningful path taking
$\Fflow$ back to $\Fout$: we simply exactly reverse the motion of the fine mesh, restoring it to its original position in as many iterations as were taken by the flow.
%
As the coarse mesh moves, we detect and respond to would-be intersections between the expanding fine mesh and the current coarse mesh.

We can describe each reverse step in our flow in terms of a displacement per
time step, that is, in terms of virtual \emph{velocities}. For the fine mesh, the
positions after the next reverse time step are known, and thus so are its
velocities:
\begin{equation*}
\U_F(t) = 
\frac{\FVflow(t) - \FVflow(t-∆t)}{∆t},
\end{equation*}
where $\U_F(t) \in \R^{n_F \times 3}$ are the instantaneous per-vertex 3D
velocity vectors at the reversing flow time $t$.

The positions of the coarse mesh $\CVout(t-∆t)$---and in turn its similarly
defined velocities $\U_C(t)$---are not fixed. In general, there are an infinite
number of \emph{feasible} choices of $\U_C(t)$ so that the repositioned coarse
mesh $\Cout(t-∆t)$ remains free of intersections with itself and with the
\emph{re-inflating} fine mesh $\Fflow(t-∆t)$.
%
To regularize this problem, we introduce a generic energy $E(\CVout)$ measuring
the quality of the coarse mesh positions.
%
We optimize this energy to update $\CVout$ at each reverse time step:
%
\begin{align}
\label{equ:simulation}
&\min_{\CVout(t-∆t)} E\left(\CVout(t-∆t)\right) \qquad \text{ subject to: }\\
\label{equ:no-self-intersections}
&\Cout(s) \text{ does not intersect itself } \forall s\in[t,t-∆t],\\
\label{equ:no-intersections}
&\Cout(s) \text{ does not intersect } \Fflow(s) \forall s\in[t,t-∆t],
\end{align}
where we are careful to solve the \emph{continuous-time} collision problem rather
than only checking for instantaneous collisions at $s=t$ and $s=t-∆t$. This
ensures that a component of the re-inflating fine mesh does not completely tunnel through some part of the coarse mesh in a single time step.


By reformulating our problem in a manner familiar to physical simulation, we may leverage state of the art contact detection and response
methods.
%
Abstractly, we can treat these methods as ``black boxes'' (velocity filters). We input the
fine mesh $\Fflow(t)$, coarse mesh $\Cout(t)$ and desired velocities
$\U_F(t)$ and $\U_C^*(t)$, where $\U_C^*(t)$ is a descent direction minimizing $E$. The black box outputs new adjusted velocities $\U^+_F(t)$ and
$\U^+_C(t)$ satisfying the non-intersecting constraint
\ref{equ:no-self-intersections}-\ref{equ:no-intersections}.

There remains one interesting twist. Our problem requires the fine mesh to
return exactly to its original positions: $\U^+_F(t) = \U_F(t)$. In
physically-based simulation parlance, this is tantamount to assigning the fine
mesh \emph{infinite mass}.
%
While collision handling is a black box in theory, in practice, the many, many collisions that occur between the coarse and fine meshes, the self-intersecting and degenerate nature of the initial fine mesh, and the fact that the moving mesh has infinite mass, all contribute to a very challenging contact problem beyond the scope of typical cloth and thin shell collision codes. We found two methods that can solve the problem successfully:

First, we adapt the surface tracking method of \cite{Brochu:2009} to deal
better with infinite masses by removing the \emph{rigid impact zone} phase as
it is incongruous with our non-rigidly deforming fine mesh. In cases when
this method fails to find a feasible solution, we subdivide $∆t$ recursively.

In particularly difficult cases, too many time step subdivisions are needed,
suggesting failure to make progress in finite time. To handle these hard cases,
we fall back on a second, more robust but slower method: speculative
asynchronous contact mechanics \cite{Ainsley:2012:SPA}. This method is an
extension of the only known method to guarantee intersection prevention and
positive progress for \emph{finite mass} objects \cite{Harmon:2009}. Even this
slowest, most robust algorithm does not guarantee that the collisions can be
resolved (in cases where the fine mesh tries to ``pinch'' the coarse mesh, no
solution can possibly exist, for instance) but in practice we see success,
albeit at a slow pace.

\paragraph{Choice of energy}
%
We experimented with a number of energies $E$. We briefly describe their
implementations and unique benefits.

The simplest energies are those measuring vertex displacement in a least
squares sense.
%
These energies have the form:
%
\begin{align}
%
E_\text{init} &= \|\CVinp       - \CVout(t-∆t)\|²_\Cout\\
  & \drsh \U_C^*(t) \sim \CVinp - \CVout(t-∆t), \\
E_\text{step} &= \|\CVout(t)    - \CVout(t-∆t)\|²_\Cout\\
  & \drsh \U_C^*(t) \sim \CVout(t) - \CVout(t-∆t), \\
E_\text{drag} &= \|\CVout(t-∆t) - \CVout(t-∆t)\|²_\Cout = 0\\
  & \drsh \U_C^*(t) = 0,
%
\end{align}
where $E_\text{init}$ penalizes displacement with respect to the coarse mesh's
initial positions, $E_\text{step}$ with respect to its position at the
beginning of the time step and $E_\text{drag}$ with respect to its current
position.

These energies successfully regularize the space of feasible solutions, but do
not encourage much in terms of \emph{quality}.

For multiresolution hierarchies or collision detection, we propose a volume
energy to encourage very tight fitting cages:
%
\begin{align}
E_\text{vol} &= ∫\limits_{\text{Vol}\left(\Cout(t-∆t)\right)} 1\,dV = ∫\limits_{\Cout(t-∆t)}
\x ⋅ \n\,dA,\\
  & \drsh \U_C^*(t) \sim ∇E_\text{vol} = \N(t),
\end{align}
where $N$ are the area-weighted vertex normals.

During re-inflation, minimizing $E_\text{vol}$ will immediately start to shrink-wrap the coarse mesh $\Cout(t)$ around the expanding fine mesh $\Fflow(t)$.
%
If $\Fflow(t)$ will need to expand a significant amount, then this tight shrink-wrap behavior causes unnecessary collisions early in the reverse flow.
%
Therefore we propose first minimizing $E_\text{drag}$ for $t\rightarrow0$ in order to
find a feasible state before switching to minimizing $E_\text{vol}$ only at
$t=0$.

The null space of $E_\text{vol}$ is spanned by all zero-volume meshes, without
regard to shape quality or surface area. Shape is retained only by the fine
mesh as an obstacle.
%
In some applications, e.g.\ low-resolution conservative contact replacements or
deformation cages, surface appearance or shape-preservation is important.
%
We explored surface-based \cite{ARAP_modeling:2007} and volumetric
\cite{Chao:2010:ASG} forms of as-rigid-as-possible (also
known as co-rotational elasticity) energies:
%
\begin{align}
%
E_\text{sarap} &= ∑_{i=1}^{n_C} \argmin_{\RR \in SO(3)} ∑_{j \in N(i)} \|
\e_{ij}(t-∆t) - \RR\einp_{ij}\|²\\
  & \drsh \U_C^*(t) \sim ∇E_\text{sarap}\\
E_\text{varap} &= ∑_{t \in \mathcal{T}} \argmin_{\RR \in SO(3)} ∑_{\{ij\} \in t} \|
\e_{ij}(t-∆t) - \RR\einp_{ij}\|²\\
  & \drsh \U_C^*(t) \sim ∇_\CVout E_\text{varap}\\
%
\end{align}
where $\e_{ij}$ is the edge vector between vertices $i$ and $j$, and
$\mathcal{T}$ is a list of tetrahedron tessellating $\Cinp$. We use
\textsc{Tetgen} to create a graded mesh with few auxiliary variables at
internal Steiner vertices \cite{tetgen}. Computing gradients $∇E_\text{sarap}$
and $∇E_\text{varap}$ involves first optimizing for ``best fit rotations''
$\RR$ via polar decomposition and then computing a sparse matrix product
\cite{Chao:2010:ASG}. Computing $∇E_\text{varap}$ requires more work as
internal tetrahedra vertices are considered by the energy, but not the
gradient. Before computing gradients, we run a local-global
\cite{ARAP_modeling:2007} optimization holding surface vertices $\CVout(t-∆t)$
fixed. This converges quickly when given an initial guess from the previous
gradient computation. Regardless, our ``black box'' collision handling
dominates computation time, so gradient computation is not a bottleneck.

The combination of our energy-minimizing re-inflation and signed distance flow
leads to minimal expansion of coarse containing layers (see
\reffig{rampant-flow}).


An alternative to flowing the fine mesh inside the coarse mesh and
re-inflating, would be to begin with a fully exterior coarse mesh and ``shrink
wrap'' it around the fine mesh.
%
This idea has been considered before \cite{Peterhans:2012,Wang:2013:HPE}, but
no full solution has been developed, presumably due to considerable challenges
on models with tunneling concavities or non-trivial topologies.
