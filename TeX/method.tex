\section{Method}
\label{sec:method}

% establish input and output
The input to our method is a sequence of $k+1$ potentially overlapping
triangles meshes $(\Minp_0,\Minp_1,\dots,\Minp_k)$.
%
Each mesh $\Minp_i$ has a corresponding list of \emph{initial} vertex positions
$\MVinp_i \in \R^{n_i \times 3}$ and list of triangle indices $\T_i \in
\{1,\dots,n_i\}^{m_i \times 3}$.
%
In general, we only assume that each mesh \emph{approximates} the surface of
the same solid object.
%
In a typical scenario, $\Minp_0$ is a high-resolution \emph{original} mesh and
$\Minp_1,\dots,\Minp_k$ are decimations of decreasing resolution.
%
We require that each input mesh is \emph{watertight} \cite{Dey:2003jf}:
%
free of open boundaries, non-manifold elements, or
self-intersections.\footnote{Our input assumptions are stricter than the
\emph{solidness} of \cite{Bernstein:2013:PHH}. That definition permits
non-manifold ``shared'' vertices and edges which confuse decimators.}
%
Depending on the application, troublesome input meshes may be \emph{cleaned} as
a pre-process using available tools (e.g.\
\cite{Attene:2010vv,Jacobson:WN:2013}).

The output of our method is a new sequence of $k$ vertex positions
$\MVout_1,\dots,\MVout_k$ such that for $i=1\dots k$ each $\Mout_i =
(\MVout_i,\T_i)$ is a deformed mesh whose surface (not just vertex set) lies
strictly outside $\Mout_{i-1}$, letting $\Mout_0 = \Minp_0$. Recursively this
ensures that each $\Mout_i$ lies strictly outside $\Mout_j$ for
$j=i-1,\dots,0$. We call such meshes \emph{nested} (see
\reffig{boxing-layers}).

\begin{figure}
  \includegraphics[width=\linewidth]{figs/boxing-layers}
  \caption{We deform a set of input overlapping decimations so that each
  contains all finer layers (2D illustration).}
  \label{fig:boxing-layers}
\end{figure}

We opt to alter only the vertex positions (\emph{geometric embedding}) of each
mesh, and not the number or connectivity of vertices ($\T_i$ are unchanged).
Among other benefits, this design decision ensures that the number of vertices
in each decimated mesh is exactly maintained.

The \emph{nesting} property of the output meshes is easily \emph{verified} by
testing that the winding number of at least one vertex of $\MVout_{i-1}$ with
respect to $\Mout_i$ is positive and no intersections exist between
$\Mout_{i-1}$ and $\Mout_i$.

Now we describe a general method that guarantees this nesting property while
optimizing any problem specific energy (e.g.\ mesh
volumes, mesh surface quality).

Our method operates recursively on two meshes of the sequence at a time: we
compute $\Mout_i$ by considering only its original embedding $\Minp_i$ and the
solution to the previous level $\Mout_{i-1}$. 
%
In this way we compute $\Mout_1,\Mout_2,\dots,\Mout_k$ in order, ensuring
nesting between each subsequent pair.
%
Breaking the problem of nesting many cages into individual subproblems is key
to our success as it will greatly reduce the complexity of the optimization
problems described later on.

To simplify notation, from now on, we only consider compute the new positions
of a \emph{coarse} mesh $\Cout$ from its original mesh $\Cinp$ and the next
\emph{finer} mesh $\Fout$. 
%
Computing new coarse mesh vertex positions $\CVout$ involves two phases:
\emph{flow} the fine mesh until fully inside the coarse mesh, \emph{re-inflate}
the fine mesh to its original embedding while \emph{pushing} the coarse mesh
out of the way (see \reffig{boxing-pipeline}).

\begin{figure}
  \includegraphics[width=\linewidth]{figs/boxing-pipeline}
  \caption{Our pipeline has two stages for each pair of neighboring coarse
  $\Cout$ and fine $\Fout$ layers.}
  \label{fig:boxing-pipeline}
\end{figure}

\subsection{Flow}
\label{sec:flow}

Without loss of generality, the fine mesh $\Fout$ and coarse mesh
$\Cinp$ are free of \emph{self}-intersections,
%
but, in general, the fine mesh will overlap the coarse mesh: some triangles of
the fine mesh will intersect those of the coarse mesh, implying that some
portion of $\Fout$ lies outside of $\Cinp$. Equivalently, there exists a
non-empty set of points on $\Fout$ with \emph{positive} signed distance with
respect to $\Cinp$, assuming a negative-inside/positive-outside convention.
%
Our idea is to find a new embedding of the fine mesh $\FVflow$ which
\emph{minimizes signed distance} integrated over all deformed surface points
$\pflow$ closest point $\qinp$ on the coarse mesh:
%
\begin{align}
\label{equ:sd-energy}
 Φ(\FVflow) &= ∫_{\Fout} s(\pflow) u(\pflow) \,dA,\\
& u(\pflow) = \left\| \pflow - \argmin_{\qinp \in \Cinp} \|\pflow-\qinp\|\right\|,\\
& s(\pflow) = \begin{cases}
  1 &  \text{ if $\pflow$    is outside $\Cinp$},\\
  0 &  \text{ if $\pflow$ is exactly on $\Cinp$},\\
  -1 & \text{ if $\pflow$    is inside $\Cinp$},
\end{cases}
\end{align}
%
where $u(\pflow)$ is the \emph{unsigned} distance from $\pflow$ to
the coarse mesh and $s(\pflow)$ modulates by the appropriate sign.

We may immediately write the energy $Φ$ as sum of integrals over each triangle
$T_i$ in $\Fout$:
\begin{equation}
Φ(\FVflow) = ∑_{i=1}^{m_F}
  ∫_{\pflow \in T_i} s(\pflow) u(\pflow)\,dA.
\end{equation}

\leo{I would prefer to use $d$ for distance, instead of $u$}.
\alec{Me too, but we use $dA$ for the integral nearby and $u$ stands for
$u$nsigned distance.}

%
\begin{wrapfigure}{r}{1.02in}
%
\centering
%
\includegraphics[width=\linewidth]{figs/cutting-corners}
%
\end{wrapfigure}
%
It is important that $\pflow$ consider \emph{all points} on the fine mesh, not
just vertices. Though \emph{all vertices} in $\FVflow$ may lie inside the
coarse mesh, points on facets might still lie outside (see inset). It is also
important that $\qinp$ consider \emph{any point} on the coarse mesh, as the
nearest vertex may be arbitrarily farther away than the closest point along a
facet.


We minimize this energy by taking small steps opposite the gradient direction
for each vertex position $\fflow$ in $\FVflow(t)$ as a function
of a hypothetical \emph{time} variable $t$:
\begin{equation}
\dd{\fflow}{t} = -∇_{\fflow} Φ(\FVflow)
\end{equation}
%
By following this gradient, we \emph{flow} the fine mesh vertices $\Fflow(t)$
until fully inside the coarse mesh.

Our energy is similar to the data terms found in non-rigid registration
techniques \cite{chang2010geometric}. However, the sign modulator $s(\pflow)$
makes an important difference. Minimizing unsigned (positive) distances would
flow points toward the surface of the coarse mesh.  Instead, by allowing and
encouraging negative distances, points are attracted to the medial axis
\emph{within} the coarse mesh.

To update each vertex $\fflow$ we must differentiate the continuous energy in
\refequ{sd-energy}. To approximate the continuous integral in each triangle
$T_i$ incident on vertices $a,b,c$, we sample at discrete quadrature points
$\pflow_j$ and with corresponding weights $w_j$, $j=1,\dots,h$:
%
\begin{align}
Φ(\FVflow) &\approx ∑_{i=1}^{m_F} ∑_{j=1}^h w_j s(\pflow_j) u(\pflow_j),\\
& \pflow_j = 
λ_a \fflow_a + 
λ_b \fflow_b + 
λ_c \fflow_c,
\end{align}
where $λ_a,λ_b,λ_c$ are the barycentric coordinates locating
$\pflow_j$ in $T_i$.

%
We use second-order quadrature rules and see diminishing returns with more
exact schemes.
%
However, the difficulty of differentiating the unsigned distance function
$u(\pflow_j)$ remains. To tackle this, we adapt the successful iterative
closest point approach of non-rigid registration techniques. Namely, we assume
that the closest point $\qinp_j^*$ to each $\pflow_j$ remains constant
during each small time step. Likewise, we assume that the sign
$s(\pflow_j)=s_j^*$ remains constant during each small time step.


\begin{align}
\dd{\fflow}{t} &\approx 
-∇_{\fflow} ∑_{i\in N(\fflow)} ∑_{j=1}^h w_j s(\pflow_j) u(\pflow_j),\\
&= 
-∇_{\fflow} ∑_{i\in N(\fflow)} ∑_{j=1}^h w_j s_j^* \|\pflow_j -\qinp_j^*\|,\\
&=
-∑_{i\in N(\fflow)} ∑_{j=1}^h w_j s_j^* ∇_{\fflow} \|\pflow_j -\qinp_j^*\|,\\
\end{align}
where $N(\fflow)$ gathers all triangles incident on vertex $\fflow$. Applying
the chain rule and being careful when $\pflow_j\approx \qinp_j^*$ (when our
assumption that $s(\pflow_j)=s_j^*$ is invalid), we arrive at
\begin{align}
\dd{\fflow}{t} &\approx 
-∑_{i\in N(\fflow)} ∑_{j=1}^h w_j s_j^* (D\pflow_j)^\transpose ∇_{\pflow_j}
\|\pflow_j -\qinp_j^*\| \\
&=
-∑_{i\in N(\fflow)} ∑_{j=1}^h w_j λ_f \g_i,\\
,\\
&\text{ where } \g_i = \begin{cases}
s_j^* \frac{\widehat{\p}_i -\q_i^*}{\|\widehat{\p}_i -\q_i^*\|} & \text{ if } \|\widehat{\p}_i
-\q_i^*\|<\epsilon,\\
\n(\q_i^*) & \text{ otherwise },
\end{cases}
\end{align}
where $λ_f$ is the barycentric coordinate of $\pflow_i$ corresponding to
$\fflow$ and $\n(\q_i^*)$ is the unit normal at $\q_i^*$. This normal is chosen
with care to ensure that it points \emph{inside} the coarse mesh. We determine
if $\q_i^*$ lies near a vertex, near an edge or in the middle of a triangle and
use an interior-angle-weighted average of incident triangle normals, a uniform
average of incident triangle normals or triangle normal, respectively
\cite{Baerentzen:2005:SDC}.

\begin{figure*}
  \includegraphics[width=\linewidth]{figs/rampant-flow}
  \caption{Mean curvature flow \protect\cite{Kazhdan2012} shrinks the fine mesh
  (blue), but via a path outside the coarse mesh (wireframe).  During
  re-inflation this causes unnecessary collisions, leading to failure.
  Instead, our flow directly flows the fine mesh into the coarse mesh.}
  \label{fig:rampant-flow}
\end{figure*}


\alec{gather all comments from method-take-1}

\alec{if the coarse mesh collides with itself during expansion and then does
not separate, won't it be impossible for the next layer to succeed? I think
this is a symptom of the conservative nature of our approach. To guarantee
nesting we force each intermediary mesh to re-inflate strictly to its output
positions. This is sufficient but not necessary to maintain that it contains
the fine layers it encloses.}
